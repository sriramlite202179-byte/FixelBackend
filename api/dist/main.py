# AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.
# Source: D:\application\project2\FixelBackend
# This file is generated by merging multiple modules.

# --- EXTERNAL IMPORTS ---
from dotenv import load_dotenv
from datetime import datetime
from email.message import EmailMessage
from fastapi import BackgroundTasks, FastAPI, HTTPException
from fastapi import Depends, HTTPException, Header
from pydantic import BaseModel
from supabase import AsyncClient, Client, create_async_client, create_client
from typing import Any, Dict, List, Optional
from typing import Optional
from uuid import UUID
import os
import smtplib

# Prioritizing load_dotenv as requested
try:
    load_dotenv()
except NameError:
    pass # load_dotenv not imported as bare name (e.g. maybe aliased or from dotenv import *)
except Exception as e:
    print(f'Warning: Early load_dotenv() failed: {e}')


# --- MODULE: db (db.py) ---

load_dotenv()

url: str = os.environ.get("SUPABASE_URL")
key: str = os.environ.get("SUPABASE_KEY")

if not url or not key:
    # Fail gracefully or warn if env vars are missing, but for now let's raise/print
    print("Warning: SUPABASE_URL or SUPABASE_KEY not set in environment.")
    print(f"DEBUG: URL={url}, KEY={key}")

async def get_supabase():
    return await create_async_client(url or "", key or "")

# --- MODULE: models (models.py) ---

class UserProfile(BaseModel):
    id: UUID
    name: str
    mob_no: Optional[str] = None # Assuming snake_case consistency
    address: Optional[str] = None

class Technician(BaseModel):
    id: UUID
    created_at: datetime
    name: str
    phone: Optional[str] = None
    provider_role_id: Optional[str] = None # Snake_case

class Service(BaseModel):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None
    name: str
    price: int
    description: Optional[str] = None
    provider_role_id: Optional[str] = None # Snake_case

class Assignment(BaseModel):
    id: int
    created_at: datetime
    techie_id: UUID # Snake_case
    service_id: int # Snake_case
    booking_id: int # Add booking_id
    scheduled_at: Optional[datetime] = None # Snake_case
    status: Optional[str] = "active"

class Booking(BaseModel):
    id: int
    created_at: datetime
    user_id: UUID
    service_id: int
    scheduled_at: datetime
    assignment_id: Optional[int] = None
    status: Optional[str] = "pending"


class AssignmentRequest(BaseModel):
    id: int
    created_at: datetime
    booking_id: int
    techie_id: UUID
    status: Optional[str] = "pending" # pending, accepted, rejected, expired

class Notification(BaseModel):
    id: int
    created_at: datetime
    user_id: UUID
    title: str
    content: Optional[str] = None

class SubService(BaseModel):
    id: int
    created_at: datetime
    service_id: int
    name: str
    price: int
    description: Optional[str] = None

class BookingItem(BaseModel):
    id: int
    created_at: datetime
    booking_id: int
    sub_service_id: int
    price: int

# --- Read/Response Models ---

class SubServiceRead(SubService):
    pass

class ServiceRead(Service):
    sub_service: list[SubService] = []

class BookingItemRead(BookingItem):
    sub_service: Optional[SubService] = None

class AssignmentRead(Assignment):
    technician: Optional[Technician] = None
    service: Optional[Service] = None
    booking: Optional[Booking] = None

class BookingRead(Booking):
    service: Optional[Service] = None
    assignment: Optional[AssignmentRead] = None
    booking_item: list[BookingItemRead] = []

class AssignmentRequestRead(AssignmentRequest):
    booking: Optional[BookingRead] = None

class BookServiceResponse(BaseModel):
    booking: Booking




# --- MODULE: schema (schema.py) ---

class BookServiceRequest(BaseModel):
    service_id: int
    user_id: UUID
    scheduled_at: str
    sub_service_ids: list[int] = []

class UserRequest(BaseModel):
    user_id: UUID

class TechnicianRequest(BaseModel):
    techie_id: UUID

class UpdateStatusRequest(BaseModel):
    assignment_id: int
    status: str

class LoginRequest(BaseModel):
    email: str
    password: str

class RegisterRequest(BaseModel):
    email: str
    password: str
    name: str
    mob_no: str | None = None
    address: str | None = None

class ViewBookingRequest(BaseModel):
    user_id: UUID
    booking_id: int

class CancelBookingRequest(BaseModel):
    user_id: UUID
    booking_id: int

class TechnicianRegisterRequest(BaseModel):
    email: str
    password: str
    name: str
    phone: str | None = None
    provider_role_id: str | None = None

class TechnicianLoginRequest(BaseModel):
    email: str
    password: str

class AssignmentResponseRequest(BaseModel):
    request_id: int

class RegisterPushTokenRequest(BaseModel):
    token: str
    user_type: str # "user" or "technician"

class TestNotificationRequest(BaseModel):
    token: str
    title: str = "Test Notification"
    message: str = "This is a test notification"
    data: dict | None = None

# --- MODULE: utils (utils.py) ---

def send_email(to_email: str, subject: str, content: str):
    # Email logic mocked for now as per request
    print(f"MOCK EMAIL to {to_email}: [{subject}] {content}")
    return

    # import os # os must only be imported later, messes with load_dotenv
    # smtp_host = os.environ.get("SUPABASE_SMTP_HOST") or os.environ.get("SMTP_HOST")
    # smtp_port = os.environ.get("SUPABASE_SMTP_PORT") or os.environ.get("SMTP_PORT")
    # smtp_user = os.environ.get("SUPABASE_SMTP_USER") or os.environ.get("SMTP_USER")
    # smtp_pass = os.environ.get("SUPABASE_SMTP_PASS") or os.environ.get("SMTP_PASS")
    # smtp_sender = os.environ.get("SUPABASE_SMTP_SENDER") or "noreply@fixel.com"

    # if not (smtp_host and smtp_port and smtp_user and smtp_pass):
    #     print(f"MOCK EMAIL to {to_email}: [{subject}] {content}")
    #     return

    # try:
    #     msg = EmailMessage()
    #     msg.set_content(content)
    #     msg["Subject"] = subject
    #     msg["From"] = smtp_sender
    #     msg["To"] = to_email

    #     with smtplib.SMTP(smtp_host, int(smtp_port)) as server:
    #         server.starttls()
    #         server.login(smtp_user, smtp_pass)
    #         server.send_message(msg)
    #     print(f"Email sent to {to_email}")
    # except Exception as e:
    #     print(f"Failed to send email: {e}")

def send_push_notification(token: str, title: str, message: str, data: Optional[dict] = None):
    from exponent_server_sdk import (
        PushClient,
        PushMessage,
        PushServerError,
        DeviceNotRegisteredError,
    )
    import os

    if not token:
        print("No push token provided.")
        return

    try:
        response = PushClient().publish(
            PushMessage(to=token, title=title, body=message, data=data)
        )
    except PushServerError as exc:
        # Encountered some likely formatting/validation error.
        print(f"Push Server Error: {exc.errors}")
        # raise exc
    except (ConnectionError, ValueError) as exc:
        # Encountered some Connection or Request API error
        print(f"Push Connection/Value Error: {exc}")
        # raise exc

    try:
        # We got a response back, but we don't know whether it's an error yet.
        # This call raises errors so we can handle them with normal exception flows.
        response.validate_response()
    except DeviceNotRegisteredError:
        # Mark the push token as inactive
        print(f"Device not registered: {token}")
        # In a real app, you'd update your DB here to remove the token
    except Exception as exc:
        # Encountered some other Error
        print(f"Push Notification Error: {exc}")
        # raise exc
    else:
        print(f"Push Notification sent to {token}: {title} - {message}")

async def verify_user(
    authorization: Optional[str] = Header(None), 
    sbase: AsyncClient = Depends(get_supabase)
) -> str:
    """
    Verifies the user is authenticated and exists in the userprofile table.
    Returns the user_id (UUID string).
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="Missing Authorization Header")
    
    token = authorization.replace("Bearer ", "")
    
    try:
        # 1. Verify Token with Supabase Auth
        user_res = await sbase.auth.get_user(token)
        if not user_res.user:
             raise HTTPException(status_code=401, detail="Invalid Token")
        
        user_id = user_res.user.id
        
        # 2. Verify User Profile exists
        profile_res = await sbase.table("userprofile").select("id").eq("id", user_id).execute()
        if not profile_res.data:
            raise HTTPException(status_code=403, detail="User profile not found. Please register.")
            
        return user_id

    except Exception as e:
        print(f"Auth Error: {e}")
        raise HTTPException(status_code=401, detail="Authentication Failed")

async def verify_technician(
    authorization: Optional[str] = Header(None), 
    sbase: AsyncClient = Depends(get_supabase)
) -> str:
    """
    Verifies the user is authenticated and exists in the technician table.
    Returns the technician's UUID string (techie_id).
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="Missing Authorization Header")
    
    token = authorization.replace("Bearer ", "")
    
    try:
        # 1. Verify Token with Supabase Auth
        user_res = await sbase.auth.get_user(token)
        if not user_res.user:
             raise HTTPException(status_code=401, detail="Invalid Token")
        
        user_id = user_res.user.id
        
        # 2. Verify Technician exists
        # Note: We assume the 'id' in technician table matches the Supabase Auth ID (UUID)
        tech_res = await sbase.table("technician").select("id").eq("id", user_id).execute()
        if not tech_res.data:
            raise HTTPException(status_code=403, detail="Technician profile not found.")
            
        return user_id

    except Exception as e:
        print(f"Auth Error: {e}")
        raise HTTPException(status_code=401, detail="Authentication Failed")

def send_push_notification(token: str, title: str, message: str, data: Optional[dict] = None):
    from exponent_server_sdk import (
        PushClient,
        PushMessage,
        PushServerError,
        DeviceNotRegisteredError,
    )

    if not token:
        print("No push token provided.")
        return

    try:
        # Check for access token in env (optional, for enhanced security)
        session_args = {}
        access_token = os.environ.get("EXPO_ACCESS_TOKEN")
        if access_token:
            session_args["access_token"] = access_token

        response = PushClient(**session_args).publish(
            PushMessage(to=token, title=title, body=message, data=data)
        )
    except PushServerError as exc:
        print(f"Push Server Error: {exc.errors}")
    except (ConnectionError, ValueError) as exc:
        print(f"Push Connection/Value Error: {exc}")

    try:
        response.validate_response()
    except DeviceNotRegisteredError:
        print(f"Device not registered: {token}")
    except Exception as exc:
        print(f"Push Notification Error: {exc}")
    else:
        print(f"Push Notification sent to {token}: {title} - {message}")

# --- MODULE: main (main.py) ---

app = FastAPI(title="Fixel Backend", docs_url="/api/docs", redoc_url="/api/redoc", openapi_url="/api/openapi.json")

# --- User Functions ---

@app.post("/api/funcs/user.register")
async def register_user(data: RegisterRequest, sbase: AsyncClient = Depends(get_supabase)):
    # 1. Sign up with Supabase Auth
    try:
        auth_res = await sbase.auth.sign_up({
            "email": data.email,
            "password": data.password,
        })
    except Exception as e:
        print("Error: ", e)
        raise HTTPException(status_code=400, detail=str(e))

    if not auth_res.user:
        print("Error: User not found")
        # Depending on config, sign_up might return a user but require email confirmation.
        # If no user is returned, something went wrong.
        raise HTTPException(status_code=400, detail="Registration failed")

    user_id = auth_res.user.id

    # 2. Create UserProfile
    profile_data = {
        "id": user_id,
        "name": data.name,
        "mob_no": data.mob_no,
        "address": data.address
    }
    
    # Use upsert=True just in case, though it should be new
    profile_res = await sbase.table("userprofile").upsert(profile_data).execute()
    
    if not profile_res.data:
        print("Error: Profile not found")
        # Note: If automatic trigger exists, this might fail or be redundant.
        # Provided schema implies we manage this manually for now?
        # If fail, we might technically have an orphan auth user. 
        # For this task, we assume happy path or simple error.
        pass

    return {
        "user": auth_res.user,
        "session": auth_res.session,
        "profile": profile_res.data[0] if profile_res.data else None
    }

@app.post("/api/funcs/user.login")
async def login_user(data: LoginRequest, sbase: AsyncClient = Depends(get_supabase)):
    try:
        auth_res = await sbase.auth.sign_in_with_password({
            "email": data.email,
            "password": data.password
        })
        # Fetch User Profile
        user_id = auth_res.user.id
        profile_res = await sbase.table("userprofile").select("*").eq("id", user_id).execute()
        
        return {
            "user": auth_res.user,
            "session": auth_res.session,
            "profile": profile_res.data[0] if profile_res.data else None
        }
    except Exception as e:
        print(f"Login failed: {e}")
        if "email not confirmed".lower() in str(e).lower():
            raise HTTPException(status_code=403, detail="Email not confirmed. Please check your inbox to verify your email address.")

        raise HTTPException(status_code=401, detail="Invalid credentials")

@app.post("/api/funcs/service.viewServices", response_model=list[ServiceRead])
async def view_services(sbase: AsyncClient = Depends(get_supabase)):
    response = await sbase.table("service").select("*, sub_service(*)").order("id").execute()
    print(response.data)
    return response.data

@app.post("/api/funcs/service.bookService", response_model=BookServiceResponse)
async def book_service(data: BookServiceRequest, sbase: AsyncClient = Depends(get_supabase)):
    # Create Booking directly (Assignment decoupled)
    booking_data = {
        "user_id": str(data.user_id),
        "service_id": data.service_id,
        "scheduled_at": data.scheduled_at,
        "status": "pending"
    }
    booking_res = await sbase.table("bookings").insert(booking_data).execute()
    
    if not booking_res.data:
        raise HTTPException(status_code=500, detail="Failed to create booking")

    booking = booking_res.data[0]
    booking_id = booking["id"]

    # Handle Sub-services (Booking Items)
    if data.sub_service_ids:
        # Fetch prices to ensure data integrity
        ss_res = await sbase.table("sub_service").select("id, price").in_("id", data.sub_service_ids).execute()
        valid_subs = ss_res.data
        
        if valid_subs:
            items_data = [
                {
                    "booking_id": booking_id,
                    "sub_service_id": vs["id"],
                    "price": vs["price"]
                }
                for vs in valid_subs
            ]
            await sbase.table("booking_item").insert(items_data).execute()

    # Trigger Assignment
    assignment = await assign_technician(booking_id, data.service_id, data.scheduled_at)
    
    # # Notify User (Booking Received)
    # # Ideally fetch user email from UserProfile, but for now assuming we have it or just logging
    # # In a real app we'd fetch the user email. Let's try to fetch it.
    # user_res = supabase.table("userprofile").select("email").eq("id", str(data.user_id)).execute()
    # user_email = user_res.data[0]["email"] if user_res.data and "email" in user_res.data[0] else None
    
    # if user_email:
    #     send_email(user_email, "Booking Confirmation", f"Your booking (ID: {booking_id}) has been received.")

    # if assignment:
    #      # Notify User of Assignment
    #      if user_email:
    #          send_email(user_email, "Technician Assigned", f"A technician has been assigned to your booking (ID: {booking_id}).")

    return {
        "booking": booking
    }

    # Notify User (Booking Received)
    # Use helper to persist and send
    await send_notification_async(
        sbase,
        user_id=booking_res.data[0]["user_id"], # Ensure we have user_id string
        title="Booking Received",
        message=f"Your booking (ID: {booking_id}) has been received.",
        data={"booking_id": booking_id, "type": "booking_received"}
    )

@app.post("/api/funcs/user.cancelBooking")
async def cancel_booking(data: CancelBookingRequest, user_id: str = Depends(verify_user), sbase: AsyncClient = Depends(get_supabase)):
    # 1. Verify booking exists and belongs to user
    booking_res = await sbase.table("bookings").select("*").eq("id", data.booking_id).eq("user_id", user_id).execute()
    
    if not booking_res.data:
        raise HTTPException(status_code=404, detail="Booking not found or does not belong to user")
    
    booking = booking_res.data[0]
    
    if booking["status"] == "cancelled":
        return {"message": "Booking is already cancelled"}

    # 2. Update status
    update_res = await sbase.table("bookings").update({"status": "cancelled"}).eq("id", data.booking_id).execute()
    
    if not update_res.data:
        raise HTTPException(status_code=500, detail="Failed to cancel booking")

    # Notify User about cancellation confirmation (optional but good)
    await send_notification_async(
        sbase,
        user_id=user_id,
        title="Booking Cancelled",
        message=f"your booking (ID: {data.booking_id}) has been cancelled successfully.",
        data={"booking_id": data.booking_id, "type": "booking_cancelled"}
    )

    # Notify Technician if assigned
    if booking.get("assignment_id"):
        # Fetch technician ID from assignment
        assign_res = await sbase.table("assignment").select("techie_id").eq("id", booking["assignment_id"]).execute()
        if assign_res.data:
            tech_id = assign_res.data[0]["techie_id"]
            await send_notification_async(
                sbase,
                user_id=tech_id,
                title="Booking Cancelled",
                message=f"Booking (ID: {data.booking_id}) has been cancelled by the user.",
                data={"booking_id": data.booking_id, "type": "booking_cancelled"}
            )
            # Also update assignment status to cancelled if not done automatically (Assuming logic handles it or we should too)
            # Schema says assignment references booking. Usually we should cancel assignment too.
            await sbase.table("assignment").update({"status": "cancelled"}).eq("id", booking["assignment_id"]).execute()

    return {"message": "Booking cancelled successfully", "booking": update_res.data[0]}

async def send_notification_async(sbase: AsyncClient, user_id: UUID | str, title: str, message: str, data: Optional[dict] = None, token: Optional[str] = None):
    # 1. Persist to DB
    try:
        notif_data = {
            "user_id": str(user_id),
            "title": title,
            "content": message
        }
        await sbase.table("notifications").insert(notif_data).execute()
    except Exception as e:
        print(f"Failed to persist notification for {user_id}: {e}")

    # 2. Get Token if missing
    if not token:
        try:
             # Try UserProfile first
             res = await sbase.table("userprofile").select("push_token").eq("id", str(user_id)).execute()
             if res.data and res.data[0].get("push_token"):
                 token = res.data[0]["push_token"]
             else:
                 # Try Technician
                 res_tech = await sbase.table("technician").select("push_token").eq("id", str(user_id)).execute()
                 if res_tech.data and res_tech.data[0].get("push_token"):
                     token = res_tech.data[0]["push_token"]
        except Exception as e:
            print(f"Failed to fetch token for {user_id}: {e}")

    # 3. Send Push
    if token:
        send_push_notification(token, title, message, data)

async def assign_technician(booking_id: int, service_id: int, scheduled_at: str):
    sbase = await get_supabase()
    # 1. Get Service to find provider_role_id
    service_res = await sbase.table("service").select("provider_role_id").eq("id", service_id).execute()
    if not service_res.data:
        return None
    provider_role = service_res.data[0]["provider_role_id"]

    # 2. Find Technicians with matching provider_role
    tech_res = await sbase.table("technician").select("id, push_token").eq("provider_role_id", provider_role).execute()
    
    valid_techs = tech_res.data
    if not valid_techs:
        return None
        
    # 3. Check existing AssignmentRequests to filter out rejected techs
    history_res = await sbase.table("assignment_request").select("techie_id, status").eq("booking_id", booking_id).execute()
    rejected_tech_ids = {h["techie_id"] for h in history_res.data if h["status"] in ["rejected", "expired"]}
    
    eligible_techs = [t for t in valid_techs if t["id"] not in rejected_tech_ids]

    if not eligible_techs:
        # No eligible tech found (all rejected or none available)
        return None
    
    # 4. Pick first available
    selected_tech = eligible_techs[0]
    
    # 5. Create AssignmentRequest (Offer)
    # Status default is pending
    request_data = {
        "techie_id": selected_tech["id"],
        "booking_id": booking_id,
        "status": "pending"
    }
    
    # We don't have service_id or scheduled_at in AssignmentRequest schema I Defined in plan?
    # Wait, the user said "techie_id, booking_id, acceptance_status, created_at". 
    # I should stick to that schema for AssignmentRequest.
    # The 'Assignment' table still holds service/scheduled info, but we create that LATER.
    
    req_res = await sbase.table("assignment_request").insert(request_data).execute()
    
    if req_res.data:
        # 6. Update Booking status
        # We don't have an 'assignment_id' yet to link in the booking table because Assignment doesn't exist.
        # But we might want to know it's "assigned/offered".
        # Let's just set status="assigned".
        # await sbase.table("bookings").update({"status": "assigned"}).eq("id", booking_id).execute()
        return req_res.data[0]
    
    # Notify Technician
    if selected_tech.get("push_token"):
         await send_notification_async(
             sbase,
             user_id=selected_tech["id"],
             title="New Booking Available",
             message=f"You have a new booking request.",
             data={"booking_id": booking_id, "type": "assignment_request"},
             token=selected_tech["push_token"]
         )
    
    return None


@app.post("/api/funcs/user.viewBookedServices", response_model=list[BookingRead])
async def view_booked_services(user_id: str = Depends(verify_user), sbase: AsyncClient = Depends(get_supabase)):
    # Query bookings table, join service directly (since assignment might be null)
    # Supabase join: select(*, service(*))
    # Supabase join: select(*, service(*), booking_item(*, sub_service(*)))
    response = await sbase.table("bookings").select("*, service:service_id(*), booking_item(*, sub_service(*))").eq("user_id", user_id).order("created_at", desc=True).execute()
    print(response.data)
    return response.data

@app.post("/api/funcs/user.viewBooking", response_model=BookingRead)
async def view_booking(data: ViewBookingRequest, user_id: str = Depends(verify_user), sbase: AsyncClient = Depends(get_supabase)):
    response = await sbase.table("bookings").select("*, service:service_id(*), assignment:assignment_id(*, technician:techie_id(*)), booking_item(*, sub_service(*))").eq("id", data.booking_id).eq("user_id", user_id).execute()
    
    if not response.data:
         raise HTTPException(status_code=404, detail="Booking not found")
    
    return response.data[0]

@app.post("/api/funcs/user.viewUser", response_model=list[UserProfile])
async def view_user(user_id: str = Depends(verify_user), sbase: AsyncClient = Depends(get_supabase)):
    response = await sbase.table("userprofile").select("*").eq("id", user_id).execute()
    print(response.data)
    return response.data

@app.post("/api/funcs/notification.viewNotifications", response_model=list[Notification])
async def view_notifications(user_id: str = Depends(verify_user), sbase: AsyncClient = Depends(get_supabase)):
    response = await sbase.table("notifications").select("*").eq("user_id", user_id).execute()
    return response.data

@app.post("/api/funcs/utils.registerPushToken")
async def register_push_token(data: RegisterPushTokenRequest, authorization: Optional[str] = Header(None), sbase: AsyncClient = Depends(get_supabase)):
    # Re-using logic from verify code roughly, but generic
    if not authorization:
         raise HTTPException(status_code=401, detail="Missing Token")
    token = authorization.replace("Bearer ", "")
    user_res = await sbase.auth.get_user(token)
    if not user_res.user:
         raise HTTPException(status_code=401, detail="Invalid Token")
    user_id = user_res.user.id

    table = "userprofile" if data.user_type == "user" else "technician"
    
    # Update push_token column
    try:
        await sbase.table(table).update({"push_token": data.token}).eq("id", user_id).execute()
        return {"message": "Push token updated"}
    except Exception as e:
        print(f"Failed to update push token: {e}")
        raise HTTPException(status_code=500, detail="Failed to update push token")

@app.post("/api/funcs/utils.testNotification")
async def test_notification(data: TestNotificationRequest):
    send_push_notification(
        token=data.token,
        title=data.title,
        message=data.message,
        data=data.data
    )
    return {"message": "Notification sent (or attempted)"}

# --- Technician Functions ---

@app.post("/api/funcs/technician.register")
async def register_technician(data: TechnicianRegisterRequest, sbase: AsyncClient = Depends(get_supabase)):
    # 1. Sign up with Supabase Auth
    try:
        auth_res = await sbase.auth.sign_up({
            "email": data.email,
            "password": data.password,
        })
    except Exception as e:
        print("Error: ", e)
        raise HTTPException(status_code=400, detail=str(e))

    if not auth_res.user:
        raise HTTPException(status_code=400, detail="Registration failed")

    user_id = auth_res.user.id

    # 2. Create Technician
    tech_data = {
        "id": user_id,
        "name": data.name,
        "phone": data.phone,
        "provider_role_id": data.provider_role_id
    }
    
    # Use upsert=True just in case
    tech_res = await sbase.table("technician").upsert(tech_data).execute()
    
    if not tech_res.data:
        pass # Handle error or assume success if no exception

    return {
        "user": auth_res.user,
        "session": auth_res.session,
        "technician": tech_res.data[0] if tech_res.data else None
    }

@app.post("/api/funcs/technician.login")
async def login_technician(data: TechnicianLoginRequest, sbase: AsyncClient = Depends(get_supabase)):

    try:
        auth_res = await sbase.auth.sign_in_with_password({
            "email": data.email,
            "password": data.password
        })

    

        # Check if actually a technician
        tech_res = await sbase.table("technician").select("id").eq("id", auth_res.user.id).execute()
        print(tech_res.data, auth_res.user.id)
        if not tech_res.data:
             raise HTTPException(status_code=403, detail="User is not a technician")

        return {
            "user": auth_res.user,
            "session": auth_res.session
        }
    except HTTPException as he:
        raise he
    except Exception as e:
        print(e)
        if "email not confirmed" in str(e):
             raise HTTPException(status_code=403, detail="Email not confirmed.")
        raise HTTPException(status_code=401, detail="Invalid credentials")

@app.post("/api/funcs/technician.viewProfile", response_model=Optional[Technician])
async def view_technician_profile(techie_id: str = Depends(verify_technician), sbase: AsyncClient = Depends(get_supabase)):
    response = await sbase.table("technician").select("*").eq("id", techie_id).execute()
    return response.data[0] if response.data else None

@app.post("/api/funcs/technician.viewAssignmentRequests", response_model=list[AssignmentRequestRead])
async def view_assignment_requests(techie_id: str = Depends(verify_technician), sbase: AsyncClient = Depends(get_supabase)):
    # Fetch pending requests
    # We might want to join booking and service info so they can see what it is
    # Supabase join syntax: select(*, booking:booking_id(*, service:service_id(*))) - nested might be tricky deep, but let's try shallow first or just booking.
    # Actually booking -> service_id is in Booking table.
    response = await sbase.table("assignment_request").select("*, booking:booking_id(*, service:service_id(*))").eq("techie_id", techie_id).eq("status", "pending").execute()
    return response.data

@app.post("/api/funcs/technician.viewAssignedBookings", response_model=list[AssignmentRead])
async def view_assigned_services(techie_id: str = Depends(verify_technician), sbase: AsyncClient = Depends(get_supabase)):
    # Select assignments where techie_id matches, excluding completed/cancelled
    response = await sbase.table("assignment").select("*, service:service_id(*), booking:booking_id(*)").eq("techie_id", techie_id).neq("status", "completed").neq("status", "cancelled").execute()
    return response.data

@app.post("/api/funcs/technician.viewBookingHistory", response_model=list[AssignmentRead])
async def view_booking_history(techie_id: str = Depends(verify_technician), sbase: AsyncClient = Depends(get_supabase)):
    # For now, maybe all assignments are history? Or filter by completed?
    # Let's assume viewAssigned is 'active' and history is 'past'.
    # For MVP, just return all assignments order by date desc.
    response = await sbase.table("assignment").select("*, service:service_id(*), booking:booking_id(*)").eq("techie_id", techie_id).order("scheduled_at", desc=True).execute()
    return response.data

@app.post("/api/funcs/technician.acceptAssignment")
async def accept_assignment(data: AssignmentResponseRequest, techie_id: str = Depends(verify_technician), sbase: AsyncClient = Depends(get_supabase)):
    # 1. Verify Request
    req_res = await sbase.table("assignment_request").select("*").eq("id", data.request_id).eq("techie_id", techie_id).execute()
    if not req_res.data:
        raise HTTPException(status_code=404, detail="Assignment request not found or does not belong to you")
    
    request = req_res.data[0]
    
    if request["status"] != "pending":
          raise HTTPException(status_code=400, detail="Assignment request is not pending")
          
    # 2. Get Booking to get details for Assignment
    booking_id = request["booking_id"]
    booking_res = await sbase.table("bookings").select("*").eq("id", booking_id).execute()
    if not booking_res.data:
         raise HTTPException(status_code=404, detail="Booking not found")
    
    booking = booking_res.data[0]
    if booking["status"] == "confirmed":
         return {"message": "Booking already confirmed by another technician"}

    # 3. Create Assignment
    assignment_data = {
        "techie_id": techie_id,
        "service_id": booking["service_id"],
        "booking_id": booking_id,
        "scheduled_at": booking["scheduled_at"],
        "status": "active" # or whatever status we use for active assignment
    }
    
    assign_res = await sbase.table("assignment").insert(assignment_data).execute()
    
    if not assign_res.data:
         raise HTTPException(status_code=500, detail="Failed to create assignment")
    
    assignment = assign_res.data[0]

    # 4. Update Request Status -> accepted
    await sbase.table("assignment_request").update({"status": "accepted"}).eq("id", data.request_id).execute()
    
    # 5. Update Booking Status -> confirmed
    await sbase.table("bookings").update({"status": "confirmed", "assignment_id": assignment["id"]}).eq("id", booking_id).execute()

    # Notify User
    try:
        # User ID is in booking["user_id"]
        await send_notification_async(
            sbase,
            user_id=booking["user_id"],
            title="Technician Assigned",
            message=f"A technician has been assigned to your booking.",
            data={"booking_id": booking_id, "type": "technician_assigned"}
        )
    except Exception as e:
        print(f"Error sending push to user: {e}")
    
    return {"message": "Assignment accepted", "assignment": assignment}

@app.post("/api/funcs/technician.rejectAssignment")
async def reject_assignment(data: AssignmentResponseRequest, techie_id: str = Depends(verify_technician), sbase: AsyncClient = Depends(get_supabase)):
    # 1. Verify Request
    req_res = await sbase.table("assignment_request").select("*").eq("id", data.request_id).eq("techie_id", techie_id).execute()
    if not req_res.data:
        raise HTTPException(status_code=404, detail="Assignment request not found")
        
    request = req_res.data[0]
    
    # 2. Update Request Status -> rejected
    await sbase.table("assignment_request").update({"status": "rejected"}).eq("id", data.request_id).execute()
    
    # 3. Trigger next assignment
    booking_id = request["booking_id"]
    
    # Retrieve booking details for re-assignment
    booking_res = await sbase.table("bookings").select("*").eq("id", booking_id).execute()
    if booking_res.data:
        booking = booking_res.data[0]
        # Attempt to assign to next tech
        new_assignment = await assign_technician(booking_id, booking["service_id"], booking["scheduled_at"])
        
        if not new_assignment:
            # If no one else found, maybe set booking to 'pending' or 'unfulfilled'
            await sbase.table("bookings").update({"status": "pending"}).eq("id", booking_id).execute()
            return {"message": "Assignment rejected. No other technicians available."}
            
    return {"message": "Assignment rejected. Re-assignment process triggered."}

@app.post("/api/funcs/service.updateStatus")
async def update_status(data: UpdateStatusRequest, techie_id: str = Depends(verify_technician), sbase: AsyncClient = Depends(get_supabase)):
    # 1. Verify Assignment belongs to Technician
    assign_res = await sbase.table("assignment").select("id").eq("id", data.assignment_id).eq("techie_id", techie_id).execute()
    if not assign_res.data:
        raise HTTPException(status_code=403, detail="Assignment not found or does not belong to you")

    # 2. Update status in 'bookings' table via assignment_id
    await sbase.table("bookings").update({"status": data.status}).eq("assignment_id", data.assignment_id).execute()

    # 3. Update status in 'assignment' table
    response = await sbase.table("assignment").update({"status": data.status}).eq("id", data.assignment_id).execute()

    if data.status == "completed":
        # Notify User
        try: 
            # Need to get user_id from booking to get token
            booking_res = await sbase.table("bookings").select("user_id").eq("assignment_id", data.assignment_id).execute()
            if booking_res.data:
                user_id = booking_res.data[0]["user_id"]
                
                await send_notification_async(
                    sbase,
                    user_id=user_id,
                    title="Booking Completed",
                    message="Your booking has been marked as completed.",
                    data={"booking_id": data.assignment_id, "type": "booking_completed"}
                )
        except Exception as e:
             print(f"Error sending push to user: {e}")

    elif data.status == "cancelled":
         # Notify User
        try: 
            booking_res = await sbase.table("bookings").select("user_id").eq("assignment_id", data.assignment_id).execute()
            if booking_res.data:
                user_id = booking_res.data[0]["user_id"]
                
                await send_notification_async(
                    sbase,
                    user_id=user_id,
                    title="Booking Cancelled",
                    message="Your booking has been cancelled by the technician.",
                    data={"booking_id": data.assignment_id, "type": "booking_cancelled"}
                )
        except Exception as e:
             print(f"Error sending push to user: {e}")

    return response.data

# --- Admin Functions (CRUD) ---

# Service CRUD
@app.post("/api/funcs/admin.service.create")
async def admin_create_service(service: Service, sbase: AsyncClient = Depends(get_supabase)):
    data = service.model_dump(exclude={"id", "created_at", "updated_at"})
    response = await sbase.table("service").insert(data).execute()
    return response.data

@app.post("/api/funcs/admin.service.update")
async def admin_update_service(id: int, updates: Dict[str, Any], sbase: AsyncClient = Depends(get_supabase)):
    response = await sbase.table("service").update(updates).eq("id", id).execute()
    return response.data

@app.post("/api/funcs/admin.service.delete")
async def admin_delete_service(id: int, sbase: AsyncClient = Depends(get_supabase)):
    response = await sbase.table("service").delete().eq("id", id).execute()
    return response.data

# Technician CRUD
@app.post("/api/funcs/admin.technician.create")
async def admin_create_technician(tech: Technician, sbase: AsyncClient = Depends(get_supabase)):
    data = tech.model_dump(exclude={"id", "created_at"})
    response = await sbase.table("technician").insert(data).execute()
    return response.data

@app.post("/api/funcs/admin.technician.delete")
async def admin_delete_technician(id: int, sbase: AsyncClient = Depends(get_supabase)):
    response = await sbase.table("technician").delete().eq("id", id).execute()
    return response.data

# Assignment CRUD (Admin)
@app.post("/api/funcs/admin.assignment.create")
async def admin_create_assignment(assignment: Assignment, sbase: AsyncClient = Depends(get_supabase)):
    data = assignment.model_dump(exclude={"id", "created_at"})
    response = await sbase.table("assignment").insert(data).execute()
    return response.data

@app.post("/api/funcs/admin.sub_service.create")
async def admin_create_sub_service(sub_service: SubService, sbase: AsyncClient = Depends(get_supabase)):
    data = sub_service.model_dump(exclude={"id", "created_at"})
    response = await sbase.table("sub_service").insert(data).execute()
    return response.data

def main():
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

if __name__ == "__main__":
    main()
